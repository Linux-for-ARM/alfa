//! Packages build instructions

use anyhow::Result;
use colored::Colorize;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, fs, path::Path};
use toml;

use crate::{process_msg, tui::process_msg_result_err};

#[derive(Debug, Deserialize, Serialize)]
pub struct Instruction {
    pub stage: String,
    pub generic_name: Option<String>,
    pub name: String, // key for `PackageList.package` map, from this we get `version`
    pub file_name: Option<String>,
    pub dir_name: Option<String>,
    pub commands: Vec<String>,
    pub env: Option<HashMap<String, String>>,
}

impl Instruction {
    pub fn read<P: AsRef<Path>>(pth: P) -> Result<Self> {
        let contents = fs::read_to_string(&pth)?;
        let data = toml::from_str(&contents)?;

        Ok(data)
    }

    pub fn write<P: AsRef<Path>>(&self, pth: P) -> Result<()> {
        let contents = toml::to_string(&self)?;
        fs::write(&pth, contents)?;

        Ok(())
    }

    fn gen_header(&self, pkgver: &str) -> String {
        format!(
            "#!/bin/bash -e\n\
            # Build script for '{pkgname}-{pkgver}' package\n\
            # WARNING: autogenerated by ALFA (ver. {alfa_ver}). Do not edit.\n\n\
            NAME=\"{pkgname}\"\n\
            VERSION=\"{pkgver}\"\n\n",
            pkgname = &self.name,
            alfa_ver = env!("CARGO_PKG_VERSION"),
        )
    }

    /// NOTE: считаем, что скрипту передаются переменные окружения:
    /// - `ALFA_SRC_DIR` - путь до директории с исходным кодом
    fn gen_untar(&self, pkgver: &str) -> String {
        if let Some(fname) = &self.file_name {
            let s1 = format!(
                "cd $ALFA_SRC_DIR\n\
                tar -xvf {fname}\n"
            );
            let s2 = if let Some(dir) = &self.dir_name {
                format!("cd {dir}")
            } else {
                format!("cd {pkgname}-{pkgver}", pkgname = &self.name)
            };

            format!("{s1}{s2}")
        } else {
            String::new()
        }
    }

    fn gen_cmd(&self) -> String {
        let mut cmd = String::new();
        for c in &self.commands {
            cmd = format!("{cmd}\n{c}");
        }
        cmd
    }

    fn gen_exit(&self) -> String {
        format!(
            "\ncd $ALFA_SRC_DIR\n\
            for i in *; do\n\
                \tif [ -d $i ]; then\n\
                    \t\trm -rvf $i\n\
                \tfi\n\
            done"
        )
    }

    fn get_sh(&self, pkgver: &str) -> String {
        format!(
            "{header}{untar}\n{cmd}\n{exit}",
            header = self.gen_header(pkgver),
            untar = self.gen_untar(pkgver),
            cmd = self.gen_cmd(),
            exit = self.gen_exit(),
        )
    }

    pub fn gen_sh<P: AsRef<Path>>(&self, prefix: P, pkgver: &str) -> Result<()> {
        let sh = self.get_sh(pkgver);
        let pth_dir = prefix.as_ref().join(&self.stage);

        if !pth_dir.exists() {
            process_msg!(
                "Create directory '{}'",
                &pth_dir.display().to_string().dimmed()
            );
            let rslt = fs::create_dir_all(&pth_dir);
            process_msg_result_err(
                rslt.is_ok(),
                if let Err(err) = rslt { Some(err) } else { None },
            );
        }

        let pth = pth_dir.join(format!("{}.sh", &self.name));

        process_msg!(
            "Write script for package '{}'",
            format!("{}-{}", &self.name, pkgver).dimmed()
        );
        let rslt = fs::write(pth, sh);
        process_msg_result_err(
            rslt.is_ok(),
            if let Err(err) = rslt { Some(err) } else { None },
        );

        Ok(())
    }
}
